<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>mid2txt v2</title>
<style>
body { background:#111; color:#eee; font-family:monospace; padding:20px; }
pre { white-space:pre-wrap; }
button, input { margin: 5px 0; }
</style>
</head>
<body>

<h1>mid2txt Improved</h1>
<input type="file" id="fileInput" accept=".mid"><br>
<button id="convertBtn">Convert</button>
<pre id="log"></pre>

<script>
function log(msg) {
    const box = document.getElementById("log");
    box.textContent += msg + "\n";
    box.scrollTop = box.scrollHeight;
}

// Read variable-length quantity
function readVarLen(view, offset) {
    let value = 0, i = 0, b;
    do {
        b = view[offset + i];
        value = (value << 7) | (b & 0x7f);
        i++;
    } while (b & 0x80);
    return { value, length: i };
}

// Parse MIDI file
function parseMidi(array) {
    const view = new Uint8Array(array);
    let idx = 0;

    function readStr(n) {
        let s = "";
        for (let i = 0; i < n; i++) s += String.fromCharCode(view[idx++]);
        return s;
    }

    function readU32() { let v = (view[idx]<<24)|(view[idx+1]<<16)|(view[idx+2]<<8)|view[idx+3]; idx+=4; return v>>>0; }
    function readU16() { let v = (view[idx]<<8)|view[idx+1]; idx+=2; return v; }

    if (readStr(4) !== "MThd") throw "Not a MIDI file";
    const headerLen = readU32();
    const format = readU16();
    const ntrks = readU16();
    const division = readU16();
    idx += headerLen - 6;

    const tracks = [];

    for (let t = 0; t < ntrks; t++) {
        if (readStr(4) !== "MTrk") throw "Track missing";
        const len = readU32();
        const end = idx + len;
        const events = [];
        let lastStatus = null;
        let trackTime = 0;

        while (idx < end) {
            const d = readVarLen(view, idx);
            trackTime += d.value;
            idx += d.length;

            let status = view[idx];
            if (status < 0x80) {
                status = lastStatus;
            } else {
                lastStatus = status;
                idx++;
            }

            if ((status & 0xF0) === 0x80) { // noteOff
                const note = view[idx++], vel = view[idx++];
                events.push({ deltaTime: d.value, absTime: trackTime, type:"channel", subtype:"noteOff", channel:status & 0x0F, noteNumber: note, velocity: vel });
            } else if ((status & 0xF0) === 0x90) { // noteOn
                const note = view[idx++], vel = view[idx++];
                events.push({ deltaTime: d.value, absTime: trackTime, type:"channel", subtype:"noteOn", channel:status & 0x0F, noteNumber: note, velocity: vel });
            } else if ((status & 0xF0) === 0xC0) { // program change
                const prog = view[idx++];
                events.push({ deltaTime: d.value, absTime: trackTime, type:"channel", subtype:"programChange", channel:status & 0x0F, programNumber: prog });
            } else if (status === 0xFF) { // meta
                const subtype = view[idx++];
                const l = readVarLen(view, idx);
                idx += l.length;
                const data = view.slice(idx, idx+l.value);
                idx += l.value;
                if (subtype === 0x51 && l.value === 3) {
                    const mpb = (data[0]<<16)|(data[1]<<8)|data[2];
                    events.push({ deltaTime: d.value, absTime: trackTime, type:"meta", subtype:"setTempo", microsecondsPerBeat: mpb });
                }
            } else { // skip other
                idx++;
                if ((status & 0xF0)!==0xC0 && (status & 0xF0)!==0xD0) idx++;
            }
        }

        log(`Track ${t} first event absTime: ${events[0]?.absTime || 0}`);
        tracks.push(events);
    }

    return { header: { ticksPerBeat: division }, tracks };
}

// Instrument mapping
const drumReverse = {
    36:2,35:2,38:1,40:1,37:3,39:3,49:4,55:4,
    42:6,44:6,46:5,26:5,54:7,56:7,51:8,53:8,
    75:9,77:9,76:10,78:10,56:11,58:11,81:12,
    82:12,60:13,62:13,64:14,65:14,70:15,72:15,
    68:16,69:16,80:17,85:17,73:18,78:18
};

function getInstrumentId(p) {
    const m = {0:1,1:1,2:2,3:2,4:2,5:2,16:3,17:3,18:3,19:3,24:4,25:4,26:5,27:5,28:5,29:5,30:5,
               32:6,33:6,34:6,35:6,45:7,42:8,57:9,71:10,64:11,65:11,66:11,67:11,73:12,75:12,
               72:13,70:14,52:15,11:16,10:17,114:18,12:19,80:20,81:20,88:21,89:21};
    return m[p] ?? 1;
}

// Convert MIDI to text
function convertMidi(buf, filename) {
    const parsed = parseMidi(buf);
    const ticks = parsed.header.ticksPerBeat;
    const tempoEvents = [];
    const events = [];
    const currentInst = {};

    for (const track of parsed.tracks) {
        for (const e of track) {
            if (e.type === "meta" && e.subtype === "setTempo") {
                tempoEvents.push({ t: e.absTime, bpm: 60000000 / e.microsecondsPerBeat });
            }
            if (e.type === "channel" && e.subtype === "programChange") {
                currentInst[e.channel] = (e.channel === 9) ? 22 : getInstrumentId(e.programNumber);
            }
            if (e.type === "channel" && e.subtype === "noteOn" && e.velocity > 0) {
                events.push({ type:"on", t:e.absTime, n:e.noteNumber, ch:e.channel, inst: currentInst[e.channel] ?? 1, vel:e.velocity });
            }
            if (e.type === "channel" && (e.subtype==="noteOff" || (e.subtype==="noteOn" && e.velocity===0))) {
                events.push({ type:"off", t:e.absTime, n:e.noteNumber, ch:e.channel });
            }
        }
    }

    tempoEvents.sort((a,b)=>a.t-b.t);
    events.sort((a,b)=>a.t-b.t);

    function bpmAtTime(t) {
        let bpm = 120;
        for (const te of tempoEvents) { if(te.t>t) break; bpm = te.bpm; }
        return bpm;
    }

    const active = {}, notes = [];
    for (const e of events) {
        const key = e.n+"_"+e.ch;
        if (e.type === "on") active[key] = e;
        else if (active[key]) {
            const on = active[key];
            const dur = (e.t - on.t) / ticks;
            const fn = on.inst===22 && drumReverse[on.n] ? drumReverse[on.n] : on.n;
            notes.push({ time: on.t / ticks, absTime: on.t, note: fn, dur, inst: on.inst, vol: Math.round(on.vel/127*100) });
            delete active[key];
        }
    }

    notes.sort((a,b)=>a.time-b.time);

    const rests=[], ns=[], ls=[], isArr=[], vs=[], bpms=[];
    let prev = notes.length ? notes[0].time : 0;
    for (let i = 0; i < notes.length; i++) {
        const n = notes[i];
        rests.push(i>0 ? (n.time - prev).toFixed(2) : "0");
        ns.push(n.note); ls.push(n.dur.toFixed(2));
        isArr.push(n.inst); vs.push(n.vol); bpms.push(bpmAtTime(n.absTime).toFixed(2));
        prev = n.time;
    }

    return [
        "SCRMID",
        `Title: ${filename}`,
        "!",
        rests.join("\n"),
        "!",
        ns.join("\n"),
        "!",
        ls.join("\n"),
        "!",
        isArr.join("\n"),
        "!",
        vs.join("\n"),
        "!",
        bpms.join("\n"),
        "!"
    ].join("\n");
}

document.getElementById("convertBtn").onclick = async () => {
    const f = document.getElementById("fileInput").files[0];
    if (!f) { log("No file selected"); return; }

    log("Reading file...");
    const buf = await f.arrayBuffer();
    const name = f.name.replace(/\.mid$/i,"");

    log("Converting...");
    let result;
    try { result = convertMidi(buf, name); } 
    catch (e) { log("Error: "+e); return; }

    log("Saving...");
    const blob = new Blob([result], { type: "text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = name + ".txt";
    a.click();

    log("Done!");
};
</script>

</body>
</html>

